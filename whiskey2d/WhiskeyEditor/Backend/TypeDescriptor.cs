using System;
using System.Collections.Generic;
using System.Linq;
using Whiskey2D.Core;
using System.IO;
using WhiskeyEditor.Backend.Managers;

namespace WhiskeyEditor.Backend
{
    [Serializable]
    public class TypeDescriptor : CodeDescriptor 
    {

        public const string CODE_PROP_START = "\t\t#region AUTO-GENERATED BY WHISKEY2D. DO NOT EDIT. (please)";
        public const string CODE_PROP_END = "\t\t#endregion END OF AUTO-GENERATED CODE.";

        private List<PropertyDescriptor> propDescs = new List<PropertyDescriptor>();
        private List<String> scriptNames = new List<string>();




        #region EventSetup
        //public event PropertyChangedEventHandler PropertyChanged;
        //public event PropertyAddedEventHandler PropertyAdded;
        //public event PropertyRemovedEventHandler PropertyRemoved;
        public event ScriptAddedEventHandler ScriptAdded;
        public event ScriptRemovedEventHandler ScriptRemoved;

        private void firePropertyChangedEvent(PropertyChangeEventArgs args)
        {
            //if (PropertyChanged != null)
            //    PropertyChanged(this, args);
        }
        private void firePropertyAddedEvent(PropertyChangeEventArgs args)
        {
            //if (PropertyAdded != null)
            //    PropertyAdded(this, args);
        }
        private void firePropertyRemovedEvent(PropertyChangeEventArgs args)
        {
            //if (PropertyRemoved != null)
            //    PropertyRemoved(this, args);
        }
        public void fireScriptAddedEvent(ScriptChangedEventArgs args)
        {
            if (ScriptAdded != null)
                ScriptAdded(this, args);
        }
        public void fireScriptRemovedEvent(ScriptChangedEventArgs args)
        {
            if (ScriptRemoved != null)
                ScriptRemoved(this, args);
        }
        #endregion


        public TypeDescriptor(string name)
            : base(ProjectManager.Instance.ActiveProject.PathSrcObjects, name)
        {   
            addInitialProps();
            FileManager.Instance.addFileDescriptor(this);
        }

        public TypeDescriptor(string basePath, string name)
            : base(basePath, name)
        {
            addInitialProps();
            FileManager.Instance.addFileDescriptor(this);
        }

        

        public String ClassName
        {
            get { return Name; }
        }

        private void addInitialProps()
        {
            addPropertyDescriptor(new PropertyDescriptor(true, "X", new RealType(typeof(float), 0)));
            addPropertyDescriptor(new PropertyDescriptor(true, "Y", new RealType(typeof(float), 0)));
            addPropertyDescriptor(new PropertyDescriptor(true, "ID", new RealType(typeof(int), 0)));
            addPropertyDescriptor(new PropertyDescriptor(true, "Sprite", new RealType(typeof(Sprite), new Sprite())));

            Light l = new Light();
            l.Visible = false;
            addPropertyDescriptor(new PropertyDescriptor(true, "Light", new RealType(typeof(Light), l)));
            addPropertyDescriptor(new PropertyDescriptor(true, "ShadowCaster", new RealType(typeof(Boolean), false)));
            addPropertyDescriptor(new PropertyDescriptor(true,false, "Name", new RealType(typeof(String), "???")));
            addPropertyDescriptor(new PropertyDescriptor(true,"Active", new RealType(typeof(Boolean), true)));
            addPropertyDescriptor(new PropertyDescriptor(true, "IsDebug", new RealType(typeof(Boolean), false)));



        }


        //------------------------------------------------- experiment

        private static Dictionary<string, InstanceDescriptor> nullTable = new Dictionary<string, InstanceDescriptor>();
        private static Whiskey2D.Core.Managers.ObjectManager nullObjMan;
        public InstanceDescriptor createNull()
        {
            if (nullObjMan == null)
            {
                nullObjMan = new Whiskey2D.Core.Managers.Impl.DefaultObjectManager();
                nullObjMan.init();
            }
            if (nullTable.ContainsKey(ClassName))
            {
                return nullTable[ClassName];
            }
            InstanceDescriptor nullInst = new InstanceDescriptor(this, nullObjMan);
            nullInst.Name = "empty (" + ClassName+")";
            nullObjMan.updateAll();



            nullTable.Add(ClassName, nullInst);
            return nullInst;
        }
        //-------------------------------------------------------------


        public void changePropertyDescriptorName(String propName, String newPropName)
        {
            PropertyDescriptor prop = lookUpPropertyDescriptor(propName);

            if (!prop.Secure)
            {
                prop.Name = newPropName;
               // InstanceManager.Instance.syncTypeToInstances(this);
                firePropertyChangedEvent( new PropertyChangeEventArgs(propName, prop ));
            }
            else throw new WhiskeyException("Property is secure : " + propName);
        }

        public void addPropertyDescriptor(PropertyDescriptor propDesc)
        {
            if (0 == propDescs.Where((p) => p.Name.Equals(propDesc.Name)).ToList().Count)
            {
                propDesc.TypeValChanged += (s, a) =>
                {
                    firePropertyChangedEvent(a);
                };

                propDescs.Add(propDesc);
              //  InstanceManager.Instance.syncTypeToInstances(this);
                firePropertyAddedEvent(new PropertyChangeEventArgs(propDesc.Name, propDesc));
            }
            else throw new WhiskeyException("Property Already Exists : " + propDesc.Name);
        }

        public void removePropertyDescriptor(PropertyDescriptor propDesc)
        {
            if (propDescs.Contains(propDesc))
            {
                if (!propDesc.Secure)
                {
                    propDescs.Remove(propDesc);
                   // InstanceManager.Instance.syncTypeToInstances(this);
                    firePropertyRemovedEvent(new PropertyChangeEventArgs(propDesc.Name, propDesc));
                }
                else throw new WhiskeyException("Property Is Secure : " + propDesc.Name);
            }
            else throw new WhiskeyException("Property Not Found : " + propDesc.Name);
        }

        public void removePropertyDescriptor(String propName)
        {
            removePropertyDescriptor(lookUpPropertyDescriptor(propName));
        }


        public TypeVal getTypeValOfName(string name)
        {
            return lookUpPropertyDescriptor(name).TypeVal;
        }
        public void setPropertyValue(string name, object value)
        {
            PropertyDescriptor pDesc = lookUpPropertyDescriptor(name);
            try
            {
                pDesc.TypeVal.Value = value;
            }
            catch (Exception e)
            {
                throw new WhiskeyException("Cannot set type, " + name + " to given value, " + value);
            }
        }

        private PropertyDescriptor lookUpPropertyDescriptor(String name)
        {
            List<PropertyDescriptor> props = propDescs.Where(p => p.Name.Equals(name)).ToList();
            if (props.Count == 1)
            {
                return props[0];
            }
            else throw new WhiskeyException("Property Name : " + name + " had " + props.Count + " instances.");
        }

        public void addScript(String scriptName)
        {           
            scriptNames.Add(scriptName);
            fireScriptAddedEvent(new ScriptChangedEventArgs( Managers.ScriptManager.Instance.lookUpScript(scriptName)) );
        }
        public void removeScript(String scriptName)
        {
            if (scriptNames.Contains(scriptName))
            {
                scriptNames.Remove(scriptName);
                fireScriptRemovedEvent(new ScriptChangedEventArgs(Managers.ScriptManager.Instance.lookUpScript(scriptName)));
            }
            else throw new WhiskeyException("Script Not Found : " + scriptName);
        }


        public List<PropertyDescriptor> getPropertySet()
        {
            return propDescs;
        }
        public List<PropertyDescriptor> getPropertySetClone()
        {
            List<PropertyDescriptor> props = new List<PropertyDescriptor>();
            foreach (PropertyDescriptor propDesc in propDescs)
            {
                props.Add(propDesc.clone());
            }
            return props;
        }

        public List<String> getScriptNamesClone()
        {

            List<String> names = new List<string>();
            foreach (String name in scriptNames)
            {
                names.Add(name);
            }
            return names;
        }

        public List<string> getScriptNames()
        {
            return scriptNames;
        }
       
    
        protected override string CodeClassDef
        {
            get
            {
                return base.CodeClassDef + " : GameObject";
            }
        }

        


        private string getCodeFor(object val)
        {
            if (val == null) return "null";

            string typeName = val.GetType().Name;
            if (typeName.Equals(typeof(int).Name)
                    || typeName.Equals(typeof(string).Name)
                    || typeName.Equals(typeof(bool).Name)
                    || typeName.Equals(typeof(float).Name)
                    || typeName.Equals(typeof(double).Name)
                    || typeName.Equals(typeof(Single).Name)
                    || typeName.Equals(typeof(byte).Name)
                    || typeName.Equals(typeof(Int16).Name)
                    || typeName.Equals(typeof(Int32).Name)
                )
            {
                return stringify(val);
            }
            else if (typeName.Equals(typeof(Vector).Name))
            {
                Vector vec = (Vector) val;
                return "new Vector(" + vec.X + ", " + vec.Y + ")";
            }
            else if (typeName.Equals(typeof(Sprite).Name))
            {
                Sprite spr = (Sprite)val;
                return "new Sprite(" + getCodeFor(spr.ImagePath) + ", " + getCodeFor(spr.Scale) + ", " + getCodeFor(spr.Offset) + ", " + getCodeFor(spr.Depth) + ", " + getCodeFor(spr.Color) + ", " + getCodeFor(spr.Rotation) + ")";

            }
            else if (typeName.Equals(typeof(Color).Name))
            {
                Color col = (Color)val;
                return "new Color(" + col.R + ", " + col.G + ", " + col.B + ", " + col.A + ")";

            }
            else if (typeName.Equals(typeof(Microsoft.Xna.Framework.Input.Keys).Name))
            {
                Microsoft.Xna.Framework.Input.Keys k = (Microsoft.Xna.Framework.Input.Keys)val;
                return "Microsoft.Xna.Framework.Input.Keys." + k.ToString();
            }

            else
            {
                //assume that the val is an instance desc
                return "null";

                //  throw new WhiskeyException("Property is not of supported type: " + val.GetType().Name);
            }

        }
        private string stringify(object val)
        {
            if (val == null)
            {
                return "null";
            }
            else if (val.GetType() == typeof(String))
            {
                return "\"" + val + "\"";
            }
            else if (val.GetType() == typeof(float))
            {

                return "" + val + "f";
            }
            else if (val.GetType() == typeof(Boolean))
            {
                return ((Boolean)val) ? "true" : "false";
            }
            else
            {
                return "" + val;
            }

        }

        private void writeProperties(StreamWriter writer)
        {
            writer.WriteLine(CODE_PROP_START);

            foreach (PropertyDescriptor prop in propDescs)
            {
                if (!prop.Secure)
                {
                    writer.WriteLine("\t\t" + prop.toCodeDefinition());
                }
            }

            writer.WriteLine("");
            writer.WriteLine("\t\t#region INIT_VALUE_ASSIGNMENT");

            writer.WriteLine("\t\tprotected override void initProperties()");
            writer.WriteLine("\t\t{");

            foreach (PropertyDescriptor prop in propDescs)
            {

                writer.WriteLine("\t\t\t" + prop.Name + " = " + getCodeFor(prop.TypeVal.Value) + ";");
            }

            writer.WriteLine("\t\t}");

            writer.WriteLine("\t\t#endregion");
            writer.WriteLine("");

            writer.WriteLine("\t\tpublic " + Name + "( ObjectManager objMan ) : base (objMan) { }");

            writer.WriteLine("\t\t#region INIT_SCRIPTS");

            writer.WriteLine("\t\tprotected override void addInitialScripts()");
            writer.WriteLine("\t\t{");
            foreach (String scriptName in scriptNames)
            {
                writer.WriteLine("\t\t\tbase.addScript( new " + scriptName + "() );");
            }


           
            writer.WriteLine("\t\t}");

            writer.WriteLine("\t\t#endregion");

            //writer.WriteLine("\t\t#region DEFAULT CONSTRUCTOR");
            //writer.WriteLine("\t\tpublic " + Name + "(Whiskey2D.Core.Managers.ObjectManager objMan) : this () {}");
            //writer.WriteLine("\t\t#endregion");

            writer.WriteLine("");


            writer.WriteLine(CODE_PROP_END);
        }

        protected override void addSpecializedCode(StreamWriter writer)
        {

            writeProperties(writer);
            writer.WriteLine("");

            writer.WriteLine("\t\tpublic override void initializeObject()");
            writer.WriteLine("\t\t{");
            writer.WriteLine("\t\t\t//implement your code here!");
            writer.WriteLine("\t\t}");
            writer.WriteLine("");
            
        }

        protected override void processExistingCode(string[] allLines)
        {

            File.Delete(FilePath); // <-- :(
            FileStream stream = File.Create(FilePath);
            StreamWriter writer = new StreamWriter(stream);
            
            for (int i = 0 ; i < allLines.Length ; i ++)
            {

                if (allLines[i].Equals(CODE_PROP_START))
                {

                    string nextLine = allLines[i++];
                    while (!nextLine.Equals(CODE_PROP_END))
                    {
                        nextLine = allLines[i++];
                    }
                    writeProperties(writer);
                    //i++;
                }

                writer.WriteLine(allLines[i]);
            }
            writer.Flush();
            writer.Close();
            stream.Close();

            base.processExistingCode(allLines);
        }

    }
}
