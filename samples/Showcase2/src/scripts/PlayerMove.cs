using System;
using System.Collections.Generic;
using Whiskey2D.Core;
using Whiskey2D.Core.Managers;
using Whiskey2D.Core.Inputs;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Audio;

//auto-generated by Whiskey2D
namespace Project
{
	[Serializable] 
	public class PlayerMove : Script<Player>
	{
		Vector surface = Vector.Zero;
		bool jumping = false, doubleJumped = false;
		int jumpCounter = 0;
		Vector gravity = Vector.UnitY * 2;
		int waterNodes = 0;
		
		public override void onStart()
		{
		
		
			Level.Camera.TruePosition = Gob.Position;
		
		 //This code runs when the GameObject is initialized
		}
		
		public override void onUpdate() 
		{
			//Config conf = Objects.getObject<Config>("Config");
			
			
			if (Input.isNewKeyDown(Keys.Escape)){
				GameManager.SetLevel("MainMenu.state");
			}
			
			Gob.Acceleration = Vector.Zero;
			Vector friction = new Vector(.08f, 0);
			
			if (Input.isKeyDown(Keys.A)){
				Gob.Acceleration -= Vector.UnitX;
			}
			if (Input.isKeyDown(Keys.D)){
				Gob.Acceleration += Vector.UnitX;
			}
			
			if (Input.isNewKeyDown(Keys.W)){
				if (surface.Y > .8f){
					jumping = true;
					jumpCounter = 40;
					int jumpPower = 12;
					if (Gob.InWater){
						jumpPower = 12;
					}
					Gob.Velocity = new Vector(Gob.Velocity.X, 0);
					Gob.Acceleration = -gravity * jumpPower;
					doubleJumped = false;
					
					SpriteEffect fx = new SpriteEffect(Level);
					fx.Position = Gob.Position + Vector.UnitY*Gob.Bounds.Size.Y /4;
					fx.Effect = "smokeJump";
					fx.Frames = Vector.One*4;
					fx.Sprite.Scale *= .3f;
					fx.Speed = 4;
					
				} else if (((jumping && !doubleJumped) || (surface.Y < .8f && !jumping)) && !Gob.InWater){
					jumpCounter = 40;
					doubleJumped = true;
					jumping = true;
					int jumpPower = 12;
					Gob.Acceleration = -gravity * jumpPower;
					Gob.Velocity = new Vector(Gob.Velocity.X, 0);
					SpriteEffect fx = new SpriteEffect(Level);
					Vector xD = Vector.UnitX*Gob.Sprite.FrameWidth;
					if (Gob.Velocity.X < 0){ xD *= -1;}
					fx.Position = Gob.Position  - (Vector.UnitY*Gob.Bounds.Size.Y /2) - xD;
					fx.Sprite.Rotation = 1.57f;
					fx.Effect = "jump";
					fx.Frames = new Vector(4, 2);
					fx.Sprite.Scale *= .3f;
					fx.Sprite.Depth = Gob.Sprite.Depth + .01f;
					fx.Speed = 4;
				}
				
			}
			
			
			if (Input.isKeyDown(Keys.W)){
				if (jumping && jumpCounter > 0 ){
					Gob.Acceleration -= gravity * .02f * jumpCounter;
					jumpCounter --;
				}
			}
			surface = Vector.Zero;
			
			Gob.InWater = false;
			var waterBlocks = Gob.currentCollisions<WaterBlock>();
			if (waterBlocks.Count > 0){
				Gob.InWater = true;
			
				if (Gob.Y > waterBlocks[0].Gob.Bounds.Top){
					Gob.Acceleration -= gravity * 1.2f;
					if (Gob.Velocity.Y > 0){
						Gob.Velocity *= .8f;
					}
				} 
				
				
				//if (Gob.Velocity.Y < 0 ||  Math.Abs(Gob.Y - waterBlocks[0].Gob.Bounds.Top) < 50){
				//	Log.debug("can jump from water");
					surface = Vector.UnitY;
					//jumping = false;
				//}
				
//				if (waterBlocks[0].Gob.Bounds.Top > Gob.Bounds.Top){
//					surface = Vector.UnitY;
//				} 
			}
			
			
			
			Gob.Acceleration += gravity;
		
			Gob.Velocity += Gob.Acceleration;
			if (Gob.Velocity.Length > 55){
				Gob.Velocity = 55 * Gob.Velocity.Unit;
			}
			
			Gob.Velocity -= new Vector(Gob.Velocity.X * friction.X, Gob.Velocity.Y * friction.Y);
			Gob.Sprite.Scale = new Vector(50 + Math.Abs(Gob.Velocity.X*15), 256);
			
			Gob.Position += Gob.Velocity;
			
			Collisions<Wall> wallColls = Gob.currentCollisions<Wall>();
			
			
			foreach (Collision<Wall> c in wallColls){
				Gob.Position -= c.MTV;
				
				Gob.Velocity = c.Normal.Perpendicular * c.Normal.Perpendicular.dot(Gob.Velocity);
				
				if (c.Normal.Y > .8f){
					surface = c.Normal;
				
					jumping = false;
				}
			}
			
			
			if (waterBlocks.Count > 0){
				//if (Gob.Y < waterBlocks[0].Gob.Bounds.Top + 10){
					//surface = Vector.UnitY;
				//}
			}
			

			Collisions<WaterNode> wColls = Gob.currentCollisions<WaterNode>();
			if (wColls.Count != 0 && waterNodes == 0){
				Vector feet = Gob.Position + Vector.UnitY * Gob.Bounds.Size.Y;
				//feet.Y += wColls[0].Gob.Velocity.Y;
				float vel = -2f * (Gob.Velocity - wColls[0].Gob.Velocity).Length ;
				vel = Math.Max(-25, vel);
				WaterParticle.makeSplash(feet, 20, new Vector(0,vel) , 1, 1.2f, false);
			} else if (wColls.Count == 0 && waterNodes != 0){
				Vector feet = Gob.Position + Vector.UnitY * Gob.Bounds.Size.Y/2;
				float vel = -1.2f * (Gob.Velocity).Length ;
				vel = Math.Max(-10, vel);
				WaterParticle.makeSplash(feet, 8, new Vector(0,vel) , 1, 2, false);
			}
			foreach (Collision<WaterNode> coll in wColls){
				coll.Gob.Acceleration += new Vector(0f * Gob.Velocity.X, .05f * Gob.Velocity.Y);
				
			}
			waterNodes = wColls.Count;

		}
		
		public override void onClose()  
		{
		 //This code runs when the GameObject is closed
		}
		
	}
}
































































































































